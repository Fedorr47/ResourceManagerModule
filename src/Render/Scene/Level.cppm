module;

#include <string>
#include <string_view>
#include <vector>
#include <unordered_map>
#include <variant>
#include <optional>
#include <array>
#include <cctype>
#include <cstdlib>
#include <stdexcept>
#include <filesystem>
#include <algorithm>

export module core:level;

import :scene;
import :asset_manager;
import :resource_manager;
import :render_bindless;
import :file_system;
import :math_utils;

// ------------------------------------------------------------
// LevelAsset / LevelInstance
// ------------------------------------------------------------
// Goal:
//  - Represent a "scene" as a reusable asset (LevelAsset)
//  - Instantiate it into a runtime Scene (LevelInstance)
//  - Keep RHI bindings (descriptor indices) as a runtime concern
//
// Input format:
//  - JSON file (*.level.json). The schema is intentionally simple and stable.
//  - It can be generated by external tools (e.g. Blender exporter) or edited by hand.

namespace
{
	// -----------------------------
	// Tiny JSON parser (subset)
	// -----------------------------
	// Supports: object, array, string, number, bool, null.
	// Enough for small engine config/level files without third-party deps.

	struct JsonValue;
	using JsonObject = std::unordered_map<std::string, JsonValue>;
	using JsonArray  = std::vector<JsonValue>;

	struct JsonValue
	{
		using Storage = std::variant<std::nullptr_t, bool, double, std::string, JsonArray, JsonObject>;
		Storage v{};

		bool IsNull()   const noexcept { return std::holds_alternative<std::nullptr_t>(v); }
		bool IsBool()   const noexcept { return std::holds_alternative<bool>(v); }
		bool IsNumber() const noexcept { return std::holds_alternative<double>(v); }
		bool IsString() const noexcept { return std::holds_alternative<std::string>(v); }
		bool IsArray()  const noexcept { return std::holds_alternative<JsonArray>(v); }
		bool IsObject() const noexcept { return std::holds_alternative<JsonObject>(v); }

		const JsonObject& AsObject() const
		{
			if (!IsObject()) throw std::runtime_error("JSON: expected object");
			return std::get<JsonObject>(v);
		}
		const JsonArray& AsArray() const
		{
			if (!IsArray()) throw std::runtime_error("JSON: expected array");
			return std::get<JsonArray>(v);
		}
		const std::string& AsString() const
		{
			if (!IsString()) throw std::runtime_error("JSON: expected string");
			return std::get<std::string>(v);
		}
		double AsNumber() const
		{
			if (!IsNumber()) throw std::runtime_error("JSON: expected number");
			return std::get<double>(v);
		}
		bool AsBool() const
		{
			if (!IsBool()) throw std::runtime_error("JSON: expected bool");
			return std::get<bool>(v);
		}
	};

	class JsonParser
	{
	public:
		explicit JsonParser(std::string_view text) : text_(text) {}

		JsonValue Parse()
		{
			SkipWs();
			JsonValue out = ParseValue();
			SkipWs();
			if (pos_ != text_.size())
			{
				Throw("unexpected trailing characters");
			}
			return out;
		}

	private:
		std::string_view text_;
		std::size_t pos_{};

		[[noreturn]] void Throw(std::string_view msg) const
		{
			throw std::runtime_error(std::string("JSON parse error at ") + std::to_string(pos_) + ": " + std::string(msg));
		}

		char Peek() const noexcept
		{
			return (pos_ < text_.size()) ? text_[pos_] : '\0';
		}
		char Get()
		{
			if (pos_ >= text_.size())
			{
				Throw("unexpected end of input");
			}
			return text_[pos_++];
		}

		void SkipWs() noexcept
		{
			while (pos_ < text_.size())
			{
				const unsigned char c = static_cast<unsigned char>(text_[pos_]);
				if (c == ' ' || c == '\t' || c == '\n' || c == '\r')
				{
					++pos_;
					continue;
				}
				break;
			}
		}

		void Expect(char expected)
		{
			SkipWs();
			const char c = Get();
			if (c != expected)
			{
				Throw(std::string("expected '") + expected + "'");
			}
		}

		bool Match(std::string_view token)
		{
			SkipWs();
			if (text_.substr(pos_, token.size()) == token)
			{
				pos_ += token.size();
				return true;
			}
			return false;
		}

		JsonValue ParseValue()
		{
			SkipWs();
			switch (Peek())
			{
			case '{': return ParseObject();
			case '[': return ParseArray();
			case '"':
			{
				JsonValue v; v.v = ParseString(); return v;
			}
			case 't':
				if (Match("true")) { JsonValue v; v.v = true; return v; }
				break;
			case 'f':
				if (Match("false")) { JsonValue v; v.v = false; return v; }
				break;
			case 'n':
				if (Match("null")) { JsonValue v; v.v = nullptr; return v; }
				break;
			default:
				break;
			}

			// number
			if (Peek() == '-' || (Peek() >= '0' && Peek() <= '9'))
			{
				JsonValue v; v.v = ParseNumber(); return v;
			}

			Throw("unexpected token");
		}

		JsonValue ParseObject()
		{
			Expect('{');
			JsonObject obj;
			SkipWs();
			if (Peek() == '}')
			{
				Get();
				JsonValue v; v.v = std::move(obj); return v;
			}

			while (true)
			{
				SkipWs();
				if (Peek() != '"') Throw("expected string key");
				std::string key = ParseString();
				Expect(':');
				JsonValue value = ParseValue();
				obj.emplace(std::move(key), std::move(value));
				SkipWs();
				const char c = Get();
				if (c == '}') break;
				if (c != ',') Throw("expected ',' or '}'");
			}

			JsonValue v; v.v = std::move(obj); return v;
		}

		JsonValue ParseArray()
		{
			Expect('[');
			JsonArray arr;
			SkipWs();
			if (Peek() == ']')
			{
				Get();
				JsonValue v; v.v = std::move(arr); return v;
			}

			while (true)
			{
				JsonValue value = ParseValue();
				arr.push_back(std::move(value));
				SkipWs();
				const char c = Get();
				if (c == ']') break;
				if (c != ',') Throw("expected ',' or ']'");
			}

			JsonValue v; v.v = std::move(arr); return v;
		}

		std::string ParseString()
		{
			Expect('"');
			std::string out;
			while (true)
			{
				const char c = Get();
				if (c == '"')
				{
					break;
				}
				if (c == '\\')
				{
					const char e = Get();
					switch (e)
					{
					case '"': out.push_back('"'); break;
					case '\\': out.push_back('\\'); break;
					case '/': out.push_back('/'); break;
					case 'b': out.push_back('\b'); break;
					case 'f': out.push_back('\f'); break;
					case 'n': out.push_back('\n'); break;
					case 'r': out.push_back('\r'); break;
					case 't': out.push_back('\t'); break;
					case 'u':
						// Minimal handling: consume 4 hex digits and emit '?' (UTF-16 not needed for our configs).
						for (int i = 0; i < 4; ++i) { (void)Get(); }
						out.push_back('?');
						break;
					default:
						Throw("invalid string escape");
					}
					continue;
				}

				out.push_back(c);
			}
			return out;
		}

		double ParseNumber()
		{
			SkipWs();
			const std::size_t start = pos_;
			if (Peek() == '-')
			{
				++pos_;
			}
			while (Peek() >= '0' && Peek() <= '9')
			{
				++pos_;
			}
			if (Peek() == '.')
			{
				++pos_;
				while (Peek() >= '0' && Peek() <= '9')
				{
					++pos_;
				}
			}
			if (Peek() == 'e' || Peek() == 'E')
			{
				++pos_;
				if (Peek() == '+' || Peek() == '-') ++pos_;
				while (Peek() >= '0' && Peek() <= '9') ++pos_;
			}

			const std::string tmp(text_.substr(start, pos_ - start));
			char* endPtr = nullptr;
			double v = std::strtod(tmp.c_str(), &endPtr);
			if (endPtr == tmp.c_str())
			{
				Throw("invalid number");
			}
			return v;
		}
	};

	// -----------------------------
	// JSON -> typed helpers
	// -----------------------------
	const JsonValue* TryGet(const JsonObject& jsonObject, std::string_view key)
	{
		if (auto it = jsonObject.find(std::string(key)); it != jsonObject.end())
		{
			return &it->second;
		}
		return nullptr;
	}

	const JsonValue& GetReq(const JsonObject& o, std::string_view key)
	{
		if (auto* v = TryGet(o, key))
		{
			return *v;
		}
		throw std::runtime_error(std::string("Level JSON: missing required field '") + std::string(key) + "'");
	}

	std::string GetStringOpt(const JsonObject& o, std::string_view key, std::string def = {})
	{
		if (auto* v = TryGet(o, key))
		{
			if (v->IsString()) return v->AsString();
			throw std::runtime_error(std::string("Level JSON: expected string at '") + std::string(key) + "'");
		}
		return def;
	}

	bool GetBoolOpt(const JsonObject& o, std::string_view key, bool def)
	{
		if (auto* v = TryGet(o, key))
		{
			if (v->IsBool()) return v->AsBool();
			throw std::runtime_error(std::string("Level JSON: expected bool at '") + std::string(key) + "'");
		}
		return def;
	}

	float GetFloatOpt(const JsonObject& o, std::string_view key, float def)
	{
		if (auto* v = TryGet(o, key))
		{
			if (v->IsNumber()) return static_cast<float>(v->AsNumber());
			throw std::runtime_error(std::string("Level JSON: expected number at '") + std::string(key) + "'");
		}
		return def;
	}

	std::vector<float> ReadFloatArray(const JsonValue& v, std::size_t expected, std::string_view what)
	{
		if (!v.IsArray())
		{
			throw std::runtime_error(std::string("Level JSON: expected array for '") + std::string(what) + "'");
		}
		const auto& a = v.AsArray();
		if (a.size() != expected)
		{
			throw std::runtime_error(std::string("Level JSON: '") + std::string(what) + "' must have " + std::to_string(expected) + " elements");
		}
		std::vector<float> out;
		out.reserve(expected);
		for (const auto& it : a)
		{
			if (!it.IsNumber())
			{
				throw std::runtime_error(std::string("Level JSON: '") + std::string(what) + "' must contain numbers");
			}
			out.push_back(static_cast<float>(it.AsNumber()));
		}
		return out;
	}

	rendern::MaterialPerm ParsePermFlags(const JsonValue& v)
	{
		if (!v.IsArray())
		{
			throw std::runtime_error("Level JSON: material.flags must be array");
		}
		rendern::MaterialPerm flags = rendern::MaterialPerm::None;

		auto ToLowerAscii = [](std::string s)
		{
			for (char& c : s)
			{
				if (c >= 'A' && c <= 'Z')
				{
					c = static_cast<char>(c - 'A' + 'a');
				}
			}
			return s;
		};

		for (const auto& it : v.AsArray())
		{
			if (!it.IsString())
			{
				throw std::runtime_error("Level JSON: material.flags entries must be strings");
			}
			const std::string& s = it.AsString();
			const std::string norm = ToLowerAscii(s);
			if (norm == "useshadow" || norm == "use_shadow") flags |= rendern::MaterialPerm::UseShadow;
			else if (norm == "transparent") flags |= rendern::MaterialPerm::Transparent;
			else if (norm == "skinning") flags |= rendern::MaterialPerm::Skinning;
			else if (norm == "usetex" || norm == "use_tex") flags |= rendern::MaterialPerm::UseTex; // usually inferred
			else
			{
				throw std::runtime_error("Level JSON: unknown material flag: " + s);
			}
		}
		return flags;
	}

	mathUtils::Mat4 ReadMat4_ColumnMajor16(const JsonValue& v, std::string_view what)
	{
		auto a = ReadFloatArray(v, 16, what);
		mathUtils::Mat4 m(0.0f);
		// Stored as column-major array (GLM style): [c0r0,c0r1,c0r2,c0r3, c1r0,...]
		for (int col = 0; col < 4; ++col)
		{
			for (int row = 0; row < 4; ++row)
			{
				m[col][row] = a[static_cast<std::size_t>(col * 4 + row)];
			}
		}
		return m;
	}
}

export namespace rendern
{
	// -----------------------------
	// LevelAsset (pure data)
	// -----------------------------
	struct LevelMeshDef
	{
		std::string path;
		std::string debugName;
	};

	enum class LevelTextureKind : std::uint8_t
	{
		Tex2D,
		Cube
	};

	enum class LevelCubeSource : std::uint8_t
	{
		Cross,
		AutoFaces,
		Faces
	};

	struct LevelTextureDef
	{
		LevelTextureKind kind{ LevelTextureKind::Tex2D };
		TextureProperties props{};

		// Cube options
		LevelCubeSource cubeSource{ LevelCubeSource::Cross };
		std::string baseOrDir;
		std::string preferBase; // for directory scan
		std::array<std::string, 6> facePaths{};
	};

	struct LevelMaterialDef
	{
		Material material{};
		std::unordered_map<std::string, std::string> textureBindings; // slotName -> textureId
	};

	struct LevelNode
	{
		std::string name;
		int parent{ -1 };
		bool visible{ true };
		Transform transform{};

		std::string mesh;     // meshId
		std::string material; // materialId
	};

	struct LevelAsset
	{
		std::string name;

		std::unordered_map<std::string, LevelMeshDef> meshes;
		std::unordered_map<std::string, LevelTextureDef> textures;
		std::unordered_map<std::string, LevelMaterialDef> materials;

		std::optional<Camera> camera;
		std::vector<Light> lights;
		std::optional<std::string> skyboxTexture; // textureId

		std::vector<LevelNode> nodes;
	};

	// -----------------------------
	// LevelInstance (runtime glue)
	// -----------------------------
	enum class MaterialTextureSlot : std::uint8_t
	{
		Albedo,
		Normal,
		Metalness,
		Roughness,
		AO,
		Emissive
	};

	struct PendingMaterialBinding
	{
		MaterialHandle material;
		MaterialTextureSlot slot{ MaterialTextureSlot::Albedo };
		std::string textureId;
	};

	class LevelInstance
	{
	public:
		LevelInstance() = default;

		void ResolveTextureBindings(AssetManager& assets, BindlessTable& bindless, Scene& scene)
		{
			ResourceManager& rm = assets.GetResourceManager();

			auto tryGetTextureHandle = [&rm](const std::string& id) -> rhi::TextureHandle
			{
				if (auto texRes = rm.Get<TextureResource>(id))
				{
					const auto& gpu = texRes->GetResource();
					if (gpu.id != 0)
					{
						return rhi::TextureHandle{ static_cast<std::uint32_t>(gpu.id) };
					}
				}
				return {};
			};

			auto getOrCreateDesc = [&](const std::string& textureId) -> rhi::TextureDescIndex
			{
				if (auto it = textureDesc_.find(textureId); it != textureDesc_.end())
				{
					return it->second;
				}

				rhi::TextureHandle handle = tryGetTextureHandle(textureId);
				if (!handle)
				{
					return 0;
				}

				rhi::TextureDescIndex index = bindless.RegisterTexture(handle);
				textureDesc_.emplace(textureId, index);
				return index;
			};

			// Materials
			for (auto& pb : pendingBindings_)
			{
				rhi::TextureDescIndex idx = getOrCreateDesc(pb.textureId);
				if (idx == 0)
				{
					continue;
				}

				Material& m = scene.GetMaterial(pb.material);
				switch (pb.slot)
				{
				case MaterialTextureSlot::Albedo:    m.params.albedoDescIndex = idx; break;
				case MaterialTextureSlot::Normal:    m.params.normalDescIndex = idx; break;
				case MaterialTextureSlot::Metalness: m.params.metalnessDescIndex = idx; break;
				case MaterialTextureSlot::Roughness: m.params.roughnessDescIndex = idx; break;
				case MaterialTextureSlot::AO:        m.params.aoDescIndex = idx; break;
				case MaterialTextureSlot::Emissive:  m.params.emissiveDescIndex = idx; break;
				}
			}

			// Skybox
			if (skyboxTextureId_)
			{
				rhi::TextureDescIndex idx = getOrCreateDesc(*skyboxTextureId_);
				if (idx != 0)
				{
					scene.skyboxDescIndex = idx;
				}
			}
		}

		void FreeDescriptors(BindlessTable& bindless) noexcept
		{
			for (auto& [_, idx] : textureDesc_)
			{
				if (idx != 0)
				{
					bindless.UnregisterTexture(idx);
				}
			}
			textureDesc_.clear();
		}

	private:
		friend LevelInstance InstantiateLevel(Scene& scene, AssetManager& assets, BindlessTable& bindless, const LevelAsset& asset, const mathUtils::Mat4& root);

		std::unordered_map<std::string, rhi::TextureDescIndex> textureDesc_;
		std::vector<PendingMaterialBinding> pendingBindings_;
		std::optional<std::string> skyboxTextureId_;
	};

	// -----------------------------
	// Loader API
	// -----------------------------
	LevelAsset LoadLevelAssetFromJson(std::string_view levelRelativePath)
	{
		const std::filesystem::path absPath = corefs::ResolveAsset(std::filesystem::path(std::string(levelRelativePath)));
		const std::string text = FILE_UTILS::ReadAllText(absPath);

		JsonParser parser(text);
		JsonValue root = parser.Parse();
		if (!root.IsObject())
		{
			throw std::runtime_error("Level JSON: root must be object");
		}
		const JsonObject& jsonObject = root.AsObject();

		LevelAsset out;
		out.name = GetStringOpt(jsonObject, "name", "Level");

		// --- meshes ---
		if (auto* meshesV = TryGet(jsonObject, "meshes"))
		{
			const JsonObject& meshesO = meshesV->AsObject();
			for (const auto& [id, defV] : meshesO)
			{
				const JsonObject& md = defV.AsObject();
				LevelMeshDef def;
				def.path = GetStringOpt(md, "path");
				def.debugName = GetStringOpt(md, "debugName");
				if (def.path.empty())
				{
					throw std::runtime_error("Level JSON: meshes." + id + ".path is required");
				}
				out.meshes.emplace(id, std::move(def));
			}
		}

		// --- textures ---
		if (auto* texV = TryGet(jsonObject, "textures"))
		{
			const JsonObject& texO = texV->AsObject();
			for (const auto& [id, defV] : texO)
			{
				const JsonObject& td = defV.AsObject();
				LevelTextureDef def;

				const std::string kind = GetStringOpt(td, "kind", "tex2d");
				if (kind == "tex2d")
				{
					def.kind = LevelTextureKind::Tex2D;
					def.props.dimension = TextureDimension::Tex2D;
					def.props.filePath = GetStringOpt(td, "path");
					if (def.props.filePath.empty())
					{
						throw std::runtime_error("Level JSON: textures." + id + ".path is required for tex2d");
					}
				}
				else if (kind == "cube")
				{
					def.kind = LevelTextureKind::Cube;
					def.props.dimension = TextureDimension::Cube;

					const std::string source = GetStringOpt(td, "source", "cross");
					if (source == "cross")
					{
						def.cubeSource = LevelCubeSource::Cross;
						def.props.cubeFromCross = true;
						def.props.filePath = GetStringOpt(td, "cross");
						if (def.props.filePath.empty())
						{
							throw std::runtime_error("Level JSON: textures." + id + ".cross is required for cube/cross");
						}
					}
					else if (source == "auto")
					{
						def.cubeSource = LevelCubeSource::AutoFaces;
						def.baseOrDir = GetStringOpt(td, "baseOrDir");
						def.preferBase = GetStringOpt(td, "preferBase");
						if (def.baseOrDir.empty())
						{
							throw std::runtime_error("Level JSON: textures." + id + ".baseOrDir is required for cube/auto");
						}
					}
					else if (source == "faces")
					{
						def.cubeSource = LevelCubeSource::Faces;
						const JsonObject& facesO = GetReq(td, "faces").AsObject();
						def.facePaths[0] = GetStringOpt(facesO, "px");
						def.facePaths[1] = GetStringOpt(facesO, "nx");
						def.facePaths[2] = GetStringOpt(facesO, "py");
						def.facePaths[3] = GetStringOpt(facesO, "ny");
						def.facePaths[4] = GetStringOpt(facesO, "pz");
						def.facePaths[5] = GetStringOpt(facesO, "nz");

						for (const auto& p : def.facePaths)
						{
							if (p.empty())
							{
								throw std::runtime_error("Level JSON: textures." + id + ".faces must define px/nx/py/ny/pz/nz");
							}
						}
					}
					else
					{
						throw std::runtime_error("Level JSON: textures." + id + ".source must be cross|auto|faces");
					}
				}
				else
				{
					throw std::runtime_error("Level JSON: textures." + id + ".kind must be tex2d|cube");
				}

				// Common props
				def.props.srgb = GetBoolOpt(td, "srgb", true);
				def.props.generateMips = GetBoolOpt(td, "mips", true);
				def.props.flipY = GetBoolOpt(td, "flipY", false);

				out.textures.emplace(id, std::move(def));
			}
		}

		// --- materials ---
		if (auto* matsV = TryGet(jsonObject, "materials"))
		{
			const JsonObject& matsO = matsV->AsObject();
			for (const auto& [id, defV] : matsO)
			{
				const JsonObject& md = defV.AsObject();
				LevelMaterialDef def;

				if (auto* bc = TryGet(md, "baseColor"))
				{
					auto a = ReadFloatArray(*bc, 4, "baseColor");
					def.material.params.baseColor = { a[0], a[1], a[2], a[3] };
				}

				def.material.params.shininess = GetFloatOpt(md, "shininess", def.material.params.shininess);
				def.material.params.specStrength = GetFloatOpt(md, "specStrength", def.material.params.specStrength);
				def.material.params.shadowBias = GetFloatOpt(md, "shadowBias", def.material.params.shadowBias);

				def.material.params.metallic = GetFloatOpt(md, "metallic", def.material.params.metallic);
				def.material.params.roughness = GetFloatOpt(md, "roughness", def.material.params.roughness);
				def.material.params.ao = GetFloatOpt(md, "ao", def.material.params.ao);
				def.material.params.emissiveStrength = GetFloatOpt(md, "emissiveStrength", def.material.params.emissiveStrength);

				if (auto* flagsV = TryGet(md, "flags"))
				{
					def.material.permFlags = ParsePermFlags(*flagsV);
				}

				if (auto* texBindV = TryGet(md, "textures"))
				{
					const JsonObject& tbo = texBindV->AsObject();
					for (const auto& [slot, tv] : tbo)
					{
						if (!tv.IsString())
						{
							throw std::runtime_error("Level JSON: materials." + id + ".textures values must be strings");
						}
						def.textureBindings.emplace(slot, tv.AsString());
					}
				}

				out.materials.emplace(id, std::move(def));
			}
		}

		// --- camera ---
		if (auto* camV = TryGet(jsonObject, "camera"))
		{
			const JsonObject& cd = camV->AsObject();
			Camera cam;
			if (auto* p = TryGet(cd, "position"))
			{
				auto a = ReadFloatArray(*p, 3, "camera.position");
				cam.position = { a[0], a[1], a[2] };
			}
			if (auto* t = TryGet(cd, "target"))
			{
				auto a = ReadFloatArray(*t, 3, "camera.target");
				cam.target = { a[0], a[1], a[2] };
			}
			if (auto* up = TryGet(cd, "up"))
			{
				auto a = ReadFloatArray(*up, 3, "camera.up");
				cam.up = { a[0], a[1], a[2] };
			}
			cam.fovYDeg = GetFloatOpt(cd, "fovYDeg", cam.fovYDeg);
			cam.nearZ = GetFloatOpt(cd, "nearZ", cam.nearZ);
			cam.farZ = GetFloatOpt(cd, "farZ", cam.farZ);
			out.camera = cam;
		}

		// --- lights ---
		if (auto* lightsV = TryGet(jsonObject, "lights"))
		{
			for (const auto& lv : lightsV->AsArray())
			{
				const JsonObject& ld = lv.AsObject();
				Light l;
				const std::string type = GetStringOpt(ld, "type", "directional");
				if (type == "directional") l.type = LightType::Directional;
				else if (type == "point") l.type = LightType::Point;
				else if (type == "spot") l.type = LightType::Spot;
				else throw std::runtime_error("Level JSON: unknown light type: " + type);

				if (auto* p = TryGet(ld, "position"))
				{
					auto a = ReadFloatArray(*p, 3, "light.position");
					l.position = { a[0], a[1], a[2] };
				}
				if (auto* d = TryGet(ld, "direction"))
				{
					auto a = ReadFloatArray(*d, 3, "light.direction");
					l.direction = mathUtils::Normalize({ a[0], a[1], a[2] });
				}
				if (auto* c = TryGet(ld, "color"))
				{
					auto a = ReadFloatArray(*c, 3, "light.color");
					l.color = { a[0], a[1], a[2] };
				}
				l.intensity = GetFloatOpt(ld, "intensity", l.intensity);
				l.range = GetFloatOpt(ld, "range", l.range);
				l.innerHalfAngleDeg = GetFloatOpt(ld, "innerHalfAngleDeg", l.innerHalfAngleDeg);
				l.outerHalfAngleDeg = GetFloatOpt(ld, "outerHalfAngleDeg", l.outerHalfAngleDeg);
				l.attConstant = GetFloatOpt(ld, "attConstant", l.attConstant);
				l.attLinear = GetFloatOpt(ld, "attLinear", l.attLinear);
				l.attQuadratic = GetFloatOpt(ld, "attQuadratic", l.attQuadratic);

				out.lights.push_back(l);
			}
		}

		// --- skybox ---
		if (auto* sb = TryGet(jsonObject, "skybox"))
		{
			// Accept either:
			//   - string: "SkyboxTexId"
			//   - object: { "textureId": "SkyboxTexId" }  (or "texture")
			//   - null
			if (sb->IsNull())
			{
				// ok
			}
			else if (sb->IsString())
			{
				out.skyboxTexture = sb->AsString();
			}
			else if (sb->IsObject())
			{
				const JsonObject& sbo = sb->AsObject();
				const JsonValue* t = TryGet(sbo, "textureId");
				if (!t) t = TryGet(sbo, "texture");
				if (!t) t = TryGet(sbo, "id");
				if (!t)
				{
					throw std::runtime_error("Level JSON: skybox object must contain 'textureId' (or 'texture')");
				}
				if (t->IsNull())
				{
					// ok
				}
				else if (t->IsString())
				{
					out.skyboxTexture = t->AsString();
				}
				else
				{
					throw std::runtime_error("Level JSON: skybox.textureId must be string or null");
				}
			}
			else
			{
				throw std::runtime_error("Level JSON: skybox must be string, object, or null");
			}
		}

		// --- nodes ---
		if (auto* nodesV = TryGet(jsonObject, "nodes"))
		{
			for (const auto& nv : nodesV->AsArray())
			{
				const JsonObject& nd = nv.AsObject();
				LevelNode n;
				n.name = GetStringOpt(nd, "name");
				n.parent = static_cast<int>(GetFloatOpt(nd, "parent", -1.0f));
				n.visible = GetBoolOpt(nd, "visible", true);
				n.mesh = GetStringOpt(nd, "mesh");
				n.material = GetStringOpt(nd, "material");

				if (auto* trV = TryGet(nd, "transform"))
				{
					const JsonObject& td = trV->AsObject();
					Transform t;
					if (auto* matV = TryGet(td, "matrix"))
					{
						t.useMatrix = true;
						t.matrix = ReadMat4_ColumnMajor16(*matV, "transform.matrix");
					}
					else
					{
						if (auto* p = TryGet(td, "position"))
						{
							auto a = ReadFloatArray(*p, 3, "transform.position");
							t.position = { a[0], a[1], a[2] };
						}
						if (auto* r = TryGet(td, "rotationDegrees"))
						{
							auto a = ReadFloatArray(*r, 3, "transform.rotationDegrees");
							t.rotationDegrees = { a[0], a[1], a[2] };
						}
						if (auto* s = TryGet(td, "scale"))
						{
							auto a = ReadFloatArray(*s, 3, "transform.scale");
							t.scale = { a[0], a[1], a[2] };
						}
					}
					n.transform = t;
				}

				out.nodes.push_back(std::move(n));
			}
		}

		return out;
	}

	LevelInstance InstantiateLevel(Scene& scene, AssetManager& assets, BindlessTable&, const LevelAsset& asset, const mathUtils::Mat4& root)
	{
		LevelInstance inst;

		// Camera
		if (asset.camera)
		{
			scene.camera = *asset.camera;
		}

		// Lights
		for (const auto& l : asset.lights)
		{
			scene.AddLight(l);
		}

		// Textures: request loads (descriptor indices are resolved later)
		for (const auto& [id, td] : asset.textures)
		{
			if (td.kind == LevelTextureKind::Tex2D)
			{
				TextureProperties p = td.props;
				assets.LoadTextureAsync(id, std::move(p));
			}
			else
			{
				TextureProperties p = td.props;
				if (td.cubeSource == LevelCubeSource::Cross)
				{
					p.cubeFromCross = true;
					assets.LoadTextureAsync(id, std::move(p));
				}
				else if (td.cubeSource == LevelCubeSource::AutoFaces)
				{
					if (!td.preferBase.empty())
					{
						assets.LoadTextureCubeAsync(id, td.baseOrDir, td.preferBase, std::move(p));
					}
					else
					{
						assets.LoadTextureCubeAsync(id, td.baseOrDir, std::move(p));
					}
				}
				else
				{
					assets.LoadTextureCubeAsync(id, td.facePaths, std::move(p));
				}
			}
		}

		// Meshes: request loads
		std::unordered_map<std::string, MeshHandle> meshHandles;
		meshHandles.reserve(asset.meshes.size());
		for (const auto& [id, md] : asset.meshes)
		{
			MeshProperties p{};
			p.filePath = md.path;
			p.debugName = md.debugName;
			meshHandles.emplace(id, assets.LoadMeshAsync(id, std::move(p)));
		}

		// Materials: create in Scene and collect pending texture bindings
		std::unordered_map<std::string, MaterialHandle> materialHandles;
		materialHandles.reserve(asset.materials.size());
		for (const auto& [id, md] : asset.materials)
		{
			MaterialHandle h = scene.CreateMaterial(md.material);
			materialHandles.emplace(id, h);

			for (const auto& [slot, texId] : md.textureBindings)
			{
				PendingMaterialBinding pb;
				pb.material = h;
				pb.textureId = texId;

				if (slot == "albedo") pb.slot = MaterialTextureSlot::Albedo;
				else if (slot == "normal") pb.slot = MaterialTextureSlot::Normal;
				else if (slot == "metalness") pb.slot = MaterialTextureSlot::Metalness;
				else if (slot == "roughness") pb.slot = MaterialTextureSlot::Roughness;
				else if (slot == "ao") pb.slot = MaterialTextureSlot::AO;
				else if (slot == "emissive") pb.slot = MaterialTextureSlot::Emissive;
				else
				{
					throw std::runtime_error("Level JSON: unknown material texture slot: " + slot);
				}

				inst.pendingBindings_.push_back(std::move(pb));
			}
		}

		inst.skyboxTextureId_ = asset.skyboxTexture;

		// Nodes: create draw items
		std::vector<mathUtils::Mat4> world;
		world.resize(asset.nodes.size(), mathUtils::Mat4(1.0f));

		for (std::size_t i = 0; i < asset.nodes.size(); ++i)
		{
			const LevelNode& n = asset.nodes[i];
			mathUtils::Mat4 local = n.transform.ToMatrix();

			mathUtils::Mat4 parent = root;
			if (n.parent >= 0)
			{
				const std::size_t p = static_cast<std::size_t>(n.parent);
				if (p >= world.size())
				{
					throw std::runtime_error("Level JSON: node parent index out of range");
				}
				parent = world[p];
			}
			world[i] = parent * local;

			if (!n.visible)
			{
				continue;
			}
			if (n.mesh.empty())
			{
				continue;
			}

			auto meshIt = meshHandles.find(n.mesh);
			if (meshIt == meshHandles.end())
			{
				throw std::runtime_error("Level JSON: node references unknown meshId: " + n.mesh);
			}

			MaterialHandle mat{};
			if (!n.material.empty())
			{
				auto it = materialHandles.find(n.material);
				if (it == materialHandles.end())
				{
					throw std::runtime_error("Level JSON: node references unknown materialId: " + n.material);
				}
				mat = it->second;
			}

			DrawItem item{};
			item.mesh = meshIt->second;
			item.material = mat;
			item.transform.useMatrix = true;
			item.transform.matrix = world[i];
			scene.AddDraw(item);
		}

		return inst;
	}
}
