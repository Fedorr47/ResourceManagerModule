diff -ruN /mnt/data/v151_orig/assets/shaders/GlobalShaderInstanced_dx12.hlsl /mnt/data/v151/assets/shaders/GlobalShaderInstanced_dx12.hlsl
--- /mnt/data/v151_orig/assets/shaders/GlobalShaderInstanced_dx12.hlsl	2026-02-20 13:46:48.000000000 +0000
+++ /mnt/data/v151/assets/shaders/GlobalShaderInstanced_dx12.hlsl	2026-02-21 11:22:44.689187032 +0000
@@ -30,10 +30,10 @@
 Texture2D<float> gSpotShadow3 : register(t6);
 
 // Point distance cubemaps (normalized distance)
-TextureCube<float> gPointShadow0 : register(t7);
-TextureCube<float> gPointShadow1 : register(t8);
-TextureCube<float> gPointShadow2 : register(t9);
-TextureCube<float> gPointShadow3 : register(t10);
+Texture2DArray<float> gPointShadow0 : register(t7);
+Texture2DArray<float> gPointShadow1 : register(t8);
+Texture2DArray<float> gPointShadow2 : register(t9);
+Texture2DArray<float> gPointShadow3 : register(t10);
 
 // Shadow metadata buffer (one element)
 struct ShadowDataSB
@@ -475,58 +475,100 @@
     return Shadow2D(gSpotShadow3, clip, biasTexels);
 }
 
-float ShadowPoint(TextureCube<float> distCube,
+// ---------------- Point shadow sampling without TextureCube face selection ----------------
+// We bind point shadows as Texture2DArray[6] (cubemap faces), and do explicit dir->face+UV mapping.
+
+struct CubeFaceUV
+{
+    uint face;   // 0..5 : +X,-X,+Y,-Y,+Z,-Z
+    float2 uv;   // [0..1]
+};
+
+CubeFaceUV CubeDirToFaceUV(float3 dir)
+{
+    float3 a = abs(dir);
+    CubeFaceUV o;
+    float2 st; // [-1..1], +Y up
+
+    if (a.x >= a.y && a.x >= a.z)
+    {
+        float inv = 1.0f / max(a.x, 1e-6f);
+        if (dir.x > 0.0f)
+        {
+            o.face = 0u; // +X
+            st = float2(-dir.z, dir.y) * inv;
+        }
+        else
+        {
+            o.face = 1u; // -X
+            st = float2(dir.z, dir.y) * inv;
+        }
+    }
+    else if (a.y >= a.x && a.y >= a.z)
+    {
+        float inv = 1.0f / max(a.y, 1e-6f);
+        if (dir.y > 0.0f)
+        {
+            o.face = 2u; // +Y
+            st = float2(dir.x, -dir.z) * inv;
+        }
+        else
+        {
+            o.face = 3u; // -Y
+            st = float2(dir.x, dir.z) * inv;
+        }
+    }
+    else
+    {
+        float inv = 1.0f / max(a.z, 1e-6f);
+        if (dir.z > 0.0f)
+        {
+            o.face = 4u; // +Z
+            st = float2(dir.x, dir.y) * inv;
+        }
+        else
+        {
+            o.face = 5u; // -Z
+            st = float2(-dir.x, dir.y) * inv;
+        }
+    }
+
+    // st.y is +up; texture UV is +down in D3D.
+    o.uv = float2(st.x, -st.y) * 0.5f + 0.5f;
+    return o;
+}
+
+float SamplePointShadow(Texture2DArray<float> distArr, float3 dir)
+{
+    CubeFaceUV fu = CubeDirToFaceUV(dir);
+    return distArr.SampleLevel(gPointClamp, float3(fu.uv, (float) fu.face), 0).r;
+}
+
+float ShadowPoint(Texture2DArray<float> distArr,
                   float3 lightPos, float range,
                   float3 worldPos, float biasTexels)
 {
     float3 v = worldPos - lightPos;
     float d = length(v);
+    if (d >= range)
+        return 1.0f;
+
     float3 dir = v / max(d, 1e-6f);
 
-    float nd = saturate(d / max(range, 1e-3f));
+    const float nd = d / max(range, 1e-6f);
 
-    uint w, h, levels;
-    distCube.GetDimensions(0, w, h, levels);
+    uint w, h, layers, levels;
+    distArr.GetDimensions(0, w, h, layers, levels);
 
-    // Bias is expressed in "shadow texels" by the CPU. Convert to normalized [0..1] distance.
     const float invRes = 1.0f / float(max(w, h));
     const float biasNorm = biasTexels * invRes;
+    const float compare = max(nd - biasNorm, 0.0f);
 
-    const float compare = nd - biasNorm;
-
-    // Manual PCF for distance-cubemap shadows (R32_FLOAT distance).
-    float3 up = (abs(dir.y) < 0.99f) ? float3(0, 1, 0) : float3(1, 0, 0);
-    float3 T = normalize(cross(up, dir));
-    float3 B = cross(dir, T);
-
-    // ~1-2 texels in "face space".
-    const float radius = 1.5f * invRes;
-
-    const float2 taps[8] =
-    {
-        float2(-0.326f, -0.406f), float2(-0.840f, -0.074f),
-        float2(-0.696f, 0.457f), float2(-0.203f, 0.621f),
-        float2(0.962f, -0.195f), float2(0.473f, -0.480f),
-        float2(0.519f, 0.767f), float2(0.185f, -0.893f)
-    };
-
-    float lit = 0.0f;
-    {
-        float stored = distCube.SampleLevel(gPointClamp, dir, 0).r;
-        lit += (compare <= stored) ? 1.0f : 0.0f;
-    }
-
-    [unroll]
-    for (int i = 0; i < 8; ++i)
-    {
-        float3 ddir = normalize(dir + (T * taps[i].x + B * taps[i].y) * radius);
-        float stored = distCube.SampleLevel(gPointClamp, ddir, 0).r;
-        lit += (compare <= stored) ? 1.0f : 0.0f;
-    }
-
-    return lit / 9.0f;
+    const float stored = SamplePointShadow(distArr, dir);
+    return (compare <= stored) ? 1.0f : 0.0f;
 }
 
+
 // Wrapper matching CPU call-site signature: (slot, worldPos, materialBiasTexels, baseBiasTexels, slopeScaleTexels)
 // NOTE: slopeScaleTexels is currently ignored here; kept for ABI stability with C++.
 float SpotShadowFactor(uint slot, float3 worldPos, float materialBiasTexels, float baseBiasTexels, float slopeScaleTexels)
diff -ruN /mnt/data/v151_orig/src/Render/DirectX12/RHIImpl/DirectX12RHI_Device.inl /mnt/data/v151/src/Render/DirectX12/RHIImpl/DirectX12RHI_Device.inl
--- /mnt/data/v151_orig/src/Render/DirectX12/RHIImpl/DirectX12RHI_Device.inl	2026-02-20 11:41:58.000000000 +0000
+++ /mnt/data/v151/src/Render/DirectX12/RHIImpl/DirectX12RHI_Device.inl	2026-02-21 11:21:05.305456924 +0000
@@ -295,6 +295,47 @@
                 return CreateShader(stage, debugName, sourceOrBytecode);
             }
 
+        void AllocateSRV_CubeAsArray(TextureEntry& entry, DXGI_FORMAT fmt, UINT mipLevels)
+        {
+            if (entry.hasSRVArray)
+            {
+                return;
+            }
+
+            if (entry.type != TextureEntry::Type::Cube)
+            {
+                throw std::runtime_error("DX12: AllocateSRV_CubeAsArray: texture is not a cube");
+            }
+
+            const UINT idx = AllocateSrvIndex();
+
+            D3D12_CPU_DESCRIPTOR_HANDLE cpu = srvHeap_->GetCPUDescriptorHandleForHeapStart();
+            cpu.ptr += static_cast<SIZE_T>(idx) * srvInc_;
+
+            D3D12_GPU_DESCRIPTOR_HANDLE gpu = srvHeap_->GetGPUDescriptorHandleForHeapStart();
+            gpu.ptr += static_cast<UINT64>(idx) * static_cast<UINT64>(srvInc_);
+
+            D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
+            srvDesc.Format = fmt;
+            srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
+
+            // Cubemap resources are created as Texture2DArray[6]. View them explicitly as 2D array.
+            srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2DARRAY;
+            srvDesc.Texture2DArray.MostDetailedMip = 0;
+            srvDesc.Texture2DArray.MipLevels = mipLevels;
+            srvDesc.Texture2DArray.FirstArraySlice = 0;
+            srvDesc.Texture2DArray.ArraySize = 6;
+            srvDesc.Texture2DArray.PlaneSlice = 0;
+            srvDesc.Texture2DArray.ResourceMinLODClamp = 0.0f;
+
+            NativeDevice()->CreateShaderResourceView(entry.resource.Get(), &srvDesc, cpu);
+
+            entry.hasSRVArray = true;
+            entry.srvIndexArray = idx;
+            entry.srvCpuArray = cpu;
+            entry.srvGpuArray = gpu;
+        }
+
 #if CORE_DX12_HAS_DXC
             // Shader Model 6.1 (DXIL) via DXC.
             if (!supportsSM6_1_ || !EnsureDXC_())
@@ -1649,6 +1690,27 @@
                                 boundTex[cmd.slot] = GetTextureSRV(cmd.texture);
                             }
                         }
+                        else if constexpr (std::is_same_v<T, CommandBindTexture2DArray>)
+                        {
+                            if (cmd.slot < boundTex.size())
+                            {
+                                auto it = textures_.find(cmd.texture.id);
+                                if (it == textures_.end())
+                                {
+                                    throw std::runtime_error("DX12: BindTexture2DArray: texture not found in textures_ map");
+                                }
+
+                                // Ensure an Array SRV exists for cube textures.
+                                if (!it->second.hasSRVArray)
+                                {
+                                    const auto desc = it->second.resource->GetDesc();
+                                    AllocateSRV_CubeAsArray(it->second, it->second.srvFormat, desc.MipLevels);
+                                }
+
+                                TransitionTexture(cmd.texture, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
+                                boundTex[cmd.slot] = it->second.srvGpuArray;
+                            }
+                        }
                         else if constexpr (std::is_same_v<T, CommandTextureDesc>)
                         {
                             if (cmd.slot < boundTex.size())
@@ -2008,6 +2070,13 @@
             D3D12_CPU_DESCRIPTOR_HANDLE srvCpu{};
             D3D12_GPU_DESCRIPTOR_HANDLE srvGpu{};
 
+            // Optional SRV for cube textures viewed as Texture2DArray (ArraySize=6).
+            // Used for point-light distance cubemaps to avoid TextureCube face-selection seams.
+            bool hasSRVArray{ false };
+            UINT srvIndexArray{ 0 };
+            D3D12_CPU_DESCRIPTOR_HANDLE srvCpuArray{};
+            D3D12_GPU_DESCRIPTOR_HANDLE srvGpuArray{};
+
             // For Tex2D render targets
             bool hasRTV{ false };
             UINT rtvIndex{ 0 };
@@ -2398,16 +2467,17 @@
                 D3D12_COMPARISON_FUNC_LESS_EQUAL,
                 D3D12_STATIC_BORDER_COLOR_OPAQUE_WHITE);
 
-            // s2: point clamp
+            // s2: point BORDER (used by point distance cubemaps).
+            // BORDER+WHITE ensures samples slightly outside a face return far (1.0) instead of clamping to the edge texel,
+            // which can create large false-shadow patches near cubemap seams.
             samplers[2] = MakeStaticSampler(
                 2,
                 D3D12_FILTER_MIN_MAG_MIP_POINT,
-                D3D12_TEXTURE_ADDRESS_MODE_CLAMP,
-                D3D12_TEXTURE_ADDRESS_MODE_CLAMP,
-                D3D12_TEXTURE_ADDRESS_MODE_CLAMP,
+                D3D12_TEXTURE_ADDRESS_MODE_BORDER,
+                D3D12_TEXTURE_ADDRESS_MODE_BORDER,
+                D3D12_TEXTURE_ADDRESS_MODE_BORDER,
                 D3D12_COMPARISON_FUNC_ALWAYS,
-                D3D12_STATIC_BORDER_COLOR_OPAQUE_BLACK);
-
+                D3D12_STATIC_BORDER_COLOR_OPAQUE_WHITE);
             // s3: linear clamp (cubemaps: skybox / IBL env)
             samplers[3] = MakeStaticSampler(
                 3,
diff -ruN /mnt/data/v151_orig/src/Render/DirectX12/RendererImpl/DirectX12Renderer_RenderFrame_04_MainPass.inl /mnt/data/v151/src/Render/DirectX12/RendererImpl/DirectX12Renderer_RenderFrame_04_MainPass.inl
--- /mnt/data/v151_orig/src/Render/DirectX12/RendererImpl/DirectX12Renderer_RenderFrame_04_MainPass.inl	2026-02-20 13:17:08.000000000 +0000
+++ /mnt/data/v151/src/Render/DirectX12/RendererImpl/DirectX12Renderer_RenderFrame_04_MainPass.inl	2026-02-21 11:18:23.557492723 +0000
@@ -81,7 +81,7 @@
 					for (std::size_t pointShadowIndex = 0; pointShadowIndex < pointShadows.size(); ++pointShadowIndex)
 					{
 						const auto tex = ctx.resources.GetTexture(pointShadows[pointShadowIndex].cube);
-						ctx.commandList.BindTextureCube(7 + static_cast<std::uint32_t>(pointShadowIndex), tex);
+						ctx.commandList.BindTexture2DArray(7 + static_cast<std::uint32_t>(pointShadowIndex), tex);
 					}
 
 					// Bind shadow metadata SB at t11
diff -ruN /mnt/data/v151_orig/src/Render/OpenGL/OpenGLRHI.cppm /mnt/data/v151/src/Render/OpenGL/OpenGLRHI.cppm
--- /mnt/data/v151_orig/src/Render/OpenGL/OpenGLRHI.cppm	2026-02-16 10:35:52.000000000 +0000
+++ /mnt/data/v151/src/Render/OpenGL/OpenGLRHI.cppm	2026-02-21 11:18:23.526003690 +0000
@@ -1276,6 +1276,12 @@
 			glBindTexture(GL_TEXTURE_CUBE_MAP, static_cast<GLuint>(cmd.texture.id));
 		}
 
+		void ExecuteOnce(const CommandBindTexture2DArray& cmd)
+		{
+			glActiveTexture(GL_TEXTURE0 + static_cast<GLenum>(cmd.slot));
+			glBindTexture(GL_TEXTURE_2D_ARRAY, static_cast<GLuint>(cmd.texture.id));
+		}
+
 		void ExecuteOnce(const CommandTextureDesc& cmd)
 		{
 			const TextureHandle& texture = ResolveTextureDesc(cmd.texture);
diff -ruN /mnt/data/v151_orig/src/Render/RHI.cppm /mnt/data/v151/src/Render/RHI.cppm
--- /mnt/data/v151_orig/src/Render/RHI.cppm	2026-02-18 08:25:43.000000000 +0000
+++ /mnt/data/v151/src/Render/RHI.cppm	2026-02-21 11:18:23.525428289 +0000
@@ -288,6 +288,11 @@
 		std::uint32_t slot{ 0 };
 		TextureHandle texture{};
 	};
+	struct CommandBindTexture2DArray
+	{
+		std::uint32_t slot{ 0 };
+		TextureHandle texture{};
+	};
 	struct CommandTextureDesc
 	{
 		std::uint32_t slot{ 0 };
